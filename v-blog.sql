/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80019
 Source Host           : 127.0.0.1:3306
 Source Schema         : v-blog

 Target Server Type    : MySQL
 Target Server Version : 80019
 File Encoding         : 65001

 Date: 17/12/2020 23:49:30
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article_tags
-- ----------------------------
DROP TABLE IF EXISTS `article_tags`;
CREATE TABLE `article_tags` (
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  KEY `index_article_id` (`article_id`) USING BTREE,
  KEY `index_tag_id` (`tag_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of article_tags
-- ----------------------------
BEGIN;
INSERT INTO `article_tags` VALUES (1, 13);
INSERT INTO `article_tags` VALUES (2, 13);
COMMIT;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '文章标题',
  `head_image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '文章首图',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章内容',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '文章简介',
  `category_id` int unsigned NOT NULL DEFAULT '0' COMMENT '文章分类id',
  `views` int unsigned NOT NULL DEFAULT '0' COMMENT '文章浏览量',
  `comment_count` int unsigned NOT NULL DEFAULT '0' COMMENT '文章评论数量',
  `is_draft` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否草稿 0-否；1-是',
  `published_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '软删除时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=114 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='文章表\n';

-- ----------------------------
-- Records of articles
-- ----------------------------
BEGIN;
INSERT INTO `articles` VALUES (1, 'Laravel 超好用代码提示工具 Laravel IDE Helper', '0a8874be3660aeb4315fe7ddd941bd75', '![file](https://cdn.learnku.com/uploads/images/201804/20/4430/1dyFsUY0ny.png?imageView2/2/w/1240/h/0)\n\nLaravel IDE Helper 是一个极其好用的代码提示及补全工具，可以给编写代码带来极大的便利。\n\n[Github 戳这里](https://github.com/barryvdh/laravel-ide-helper#automatic-phpdocs-for-models)\n\n## 安装\n\n### 安装 larave-ide-helper\n\n\n```\n# 如果只想在开发环境安装请加上 --dev\ncomposer require barryvdh/laravel-ide-helper\n```\n\n### 安装 doctrine/dbal 「请装上它，在为模型注释字段的时候必须用到它」\n\n```\n# 如果只想在开发环境安装请加上 --dev\ncomposer require \"doctrine/dbal: ~2.3\"\n```\n\n在 「config/app.php」的 「providers」数组中加入\n\n```\nBarryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class\n```\n\n> 如果你的 `Laravel` 版本小于 5.5 「如果没记错」的话，请注册服务提供者，否则请忽略\n\n如果你只在开发环境中安装「larave-ide-helper」，那么可以在「app/Providers/AppServiceProvider.php」的「register」方法中写入下面代码：\n\n```php\npublic function register()\n{\n    if ($this->app->environment() !== \'production\') {\n        $this->app->register(\\Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class);\n    }\n    // ...\n}\n```\n\n导出配置文件（如果默认配置就满足需求了，也可以忽略这一步）\n\n```\nphp artisan vendor:publish --provider=\"Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider\" --tag=config\n```\n\n好了，接下去可以愉快的使用了\n\n## 使用\n\n* php artisan ide-helper:generate - 为 Facades 生成注释\n* php artisan ide-helper:models - 为数据模型生成注释\n* php artisan ide-helper:meta - 生成 PhpStorm Meta file\n\n#### 自动为 Laravel 的 Facades 生成注释\n\n在命令行下运行\n\n```\nphp artisan ide-helper:generate\n```\n\n> 注: 如果存在文件 「bootstrap/compiled.php」 需要先删除， 可以在生成文当前运行  `php artisan clear-compiled`。\n\n#### 自动为模型生成注释\n\n为所有模型生成注释  `php artisan ide-helper:models`, 这时会出现询问：\n\n```\nDo you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No):  (yes/no) [no]:\n```\n\n输入 yes 则会直接在模型文件中写入注释，否则会生成「_ide_helper_models.php」文件。建议选择 yes，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件，不过这么做最好对模型文件做个备份，至少在生成注释之前用 git 控制一下版本，以防万一。\n\n> 提示： 为模型生成字段信息必须在数据库中存在相应的数据表，不要生成 migration 还没运行 migrate 的时候就生成注释，这样是得不到字段信息的。\n\n#### 自动为链式操作注释\n\n这是什么意思呢？举个例子，在 migration 文件中经常可以看见这样的代码：\n\n```\n$table->string(\'email\')->unique();\n```\n\n这时候就算调用过了 `php artisan ide-helper:generate`，在调用像 `->unique()` 这样的链式操作的时候也无法实现代码提示，这时候需要将配置文件「如果导出的话」`\'include_fluent\' => false` 修改为 `\'include_fluent\' => true`，重新运行 `php artisan ide-helper:generate`。试试效果吧！\n\n#### 生成 .phpStorm.meta.php\n\n可以生成一个PhpStorm meta 文件去支持工厂模式. 对于 Laravel, 这意味着我们可以让 PhpStorm 理解我们从 IoC 容器中解决了什么类型的对象。例如：事件将返回一个「Illuminate\\Events\\Dispatcher」对象，利用 meta 文件您可以调用 app(\'events\') 并且它将自动完成 Dispatcher 的方法。\n\n```php\napp(\'events\')->fire();\n\\App::make(\'events\')->fire();\n\n/** @var \\Illuminate\\Foundation\\Application $app */\n$app->make(\'events\')->fire();\n\n// When the key is not found, it uses the argument as class name\napp(\'App\\SomeClass\');\n```\n> 提示：您可能需要重启 Phpstorm 使 .phpStorm.meta.php 文件生效。\n\n#### 自动运行 generate\n\n想在依赖包更新是自动更新注释，可以在 composer.json 文件中做如下配置：\n\n```\n\"scripts\":{\n    \"post-update-cmd\": [\n        \"Illuminate\\\\Foundation\\\\ComposerScripts::postUpdate\",\n        \"php artisan ide-helper:generate\",\n        \"php artisan ide-helper:meta\"\n    ]\n}\n```\n> 提示：如果只在 dev 环境下部署 ide helper 还是不要这么做了，防止在生产环境中报错导致不必要的麻烦。\n\n## 结尾\n\n整个使用大概就是这样了，其实在 Laravel 5.5 以上版本只需要装上 \"larave-ide-helper\" 和 \"doctrine/dbal: ~2.3\" 这两个包，不用做什么配置就可以愉快的玩耍了。\n\n如发现文中错误，**请！斧！正！**\n\n[原文链接](http://caojf.com/?p=11)', '放辣椒删掉了开发见识到了副科级拉萨来得及福利卡世纪东方了卡是', 3, 100, 100, 0, '2020-11-08 16:52:40', '2020-11-08 16:52:40', '2020-12-09 12:58:49', NULL);
INSERT INTO `articles` VALUES (2, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (3, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (4, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (5, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (6, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (7, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (8, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (9, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (10, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-17 13:07:15', '2020-12-17 21:07:15');
INSERT INTO `articles` VALUES (11, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-17 13:07:22', '2020-12-17 21:07:22');
INSERT INTO `articles` VALUES (12, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (13, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (14, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (15, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (16, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (17, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (18, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (19, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (20, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (21, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (22, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (23, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (24, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (25, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (26, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (27, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (28, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (29, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (30, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (31, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (32, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (33, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (34, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (35, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (36, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (37, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (38, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (39, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (40, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (41, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (42, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (43, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (44, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (45, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (46, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (47, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (48, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (49, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (50, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (51, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (52, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (53, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (54, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (55, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (56, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (57, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (58, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (59, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (60, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (61, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (62, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (63, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (64, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (65, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (66, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (67, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (68, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (69, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (70, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (71, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (72, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (73, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (74, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (75, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (76, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (77, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (78, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (79, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (80, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (81, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (82, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (83, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (84, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (85, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (86, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (87, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (88, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (89, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (90, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (91, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (92, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (93, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (94, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (95, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (96, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (97, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (98, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (99, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (100, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (101, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (102, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (103, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (104, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (105, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (106, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (107, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (108, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (109, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (110, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (111, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (112, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
INSERT INTO `articles` VALUES (113, 'Laravel 自带的 API 守卫驱动 token 使用详解', '0a8874be3660aeb4315fe7ddd941bd75', '[原文链接](http://caojf.com/?p=89)\n\n在`Laravel`框架中，默认的用户认证守卫有两个，`web`和`api`，`web`守卫默认的驱动是`session`，而`api`守卫默认的驱动是`token`。那么，该如何使用这个`token`驱动？\n\n## 寻找 TokenGuard\n\n通过 `Auth::guard()` 这个方法，可以追溯到 `token` 驱动对应的类。来看`Illuminate\\Auth\\AuthManager`中的代码：\n\n```php\n /**\n     * Attempt to get the guard from the local cache.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     */\n    public function guard($name = null)\n    {\n        $name = $name ?: $this->getDefaultDriver();\n\n        return $this->guards[$name] ?? $this->guards[$name] = $this->resolve($name);\n    }\n\n    /**\n     * Resolve the given guard.\n     *\n     * @param  string  $name\n     * @return \\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard\n     *\n     * @throws \\InvalidArgumentException\n     */\n    protected function resolve($name)\n    {\n        $config = $this->getConfig($name);\n\n        if (is_null($config)) {\n            throw new InvalidArgumentException(\"Auth guard [{$name}] is not defined.\");\n        }\n\n        if (isset($this->customCreators[$config[\'driver\']])) {\n            return $this->callCustomCreator($name, $config);\n        }\n\n        $driverMethod = \'create\'.ucfirst($config[\'driver\']).\'Driver\';\n\n        if (method_exists($this, $driverMethod)) {\n            return $this->{$driverMethod}($name, $config);\n        }\n\n        throw new InvalidArgumentException(\"Auth driver [{$config[\'driver\']}] for guard [{$name}] is not defined.\");\n    }\n```\n可以看到，默认情况下就会调用到 `createTokenDriver` 。来看看这个方法：\n```php\n public function createTokenDriver($name, $config)\n {\n	 // The token guard implements a basic API token based guard implementation\n	 // that takes an API token field from the request and matches it to the\n	 // user in the database or another persistence layer where users are.\n	 $guard = new TokenGuard(\n		 $this->createUserProvider($config[\'provider\'] ?? null),\n		 $this->app[\'request\']\n	 );\n\n	 $this->app->refresh(\'request\', $guard, \'setRequest\');\n\n	 return $guard;\n }\n```\n\n显然，`api守卫`默认的驱动就是`TokenGuard`。\n\n## 解读 TokenGuard\n\n```php\n/**\n     * Create a new authentication guard.\n     *\n     * @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  string  $inputKey\n     * @param  string  $storageKey\n     * @return void\n     */\n    public function __construct(UserProvider $provider, Request $request, $inputKey = \'api_token\', $storageKey = \'api_token\')\n    {\n        $this->request = $request;\n        $this->provider = $provider;\n        $this->inputKey = $inputKey;\n        $this->storageKey = $storageKey;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        // If we\'ve already retrieved the user for the current request we can just\n        // return it back immediately. We do not want to fetch the user data on\n        // every call to this method because that would be tremendously slow.\n        if (! is_null($this->user)) {\n            return $this->user;\n        }\n\n        $user = null;\n\n        $token = $this->getTokenForRequest();\n\n        if (! empty($token)) {\n            $user = $this->provider->retrieveByCredentials(\n                [$this->storageKey => $token]\n            );\n        }\n\n        return $this->user = $user;\n    }\n```\n\n从构造函数和 `user()` 方法中可以看出，默认使用\n```php\n[\'api_token\' => $token]\n```\n这个数组去获取用户，也就是说，在用户表中我们需要一个字段（默认api_token）去存储标识用户的 token。\n\n## 开始使用 token 进行api认证\n\n### 添加数据表字段\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddUsersApiTokenField extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->string(\'api_token\', 60)->unique()->nullable()->after(\'password\');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table(\'users\', function (Blueprint $table) {\n            $table->dropColumn(\'api_token\');\n        });\n    }\n}\n```\n### 创建登录控制器\n\n这里不演示注册之类的，假设我们的 users 表中已经存在用户，先创建一个用于 api 登录的控制器。在每次登录的时候，更新一次用户的 api_token 。这里使用了 `ThrottlesLogins` ，用来控制登录的尝试次数。\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse Hash;\nuse App\\User;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\ThrottlesLogins;\nuse Illuminate\\Validation\\ValidationException;\n\nclass LoginController extends Controller\n{\n    use ThrottlesLogins;\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     * @throws ValidationException\n     */\n    public function login(Request $request)\n    {\n        $this->validateLogin($request);\n\n        if ($this->hasTooManyLoginAttempts($request)) {\n            return $this->sendLockoutResponse($request);\n        }\n\n        return $this->attempLogin($request);\n\n    }\n\n    /**\n     * @param Request $request\n     */\n    public function validateLogin(Request $request)\n    {\n        $this->validate($request, [\n            $this->username() => \'required|string\',\n            \'password\' => \'required|string\'\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    protected function attempLogin(Request $request)\n    {\n        $this->incrementLoginAttempts($request);\n\n        $user = User::where(\'email\', $request->email)->first();\n\n        if (!$user || !Hash::check($request->password, $user->password)) {\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        // 更新 api_key\n        $api_token = uniqid($user->id);\n        $user->api_token = $api_token;\n        $user->save();\n\n        return $this->sendLoginResponse($request, $user);\n    }\n\n    /**\n     * @param Request $request\n     */\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        throw ValidationException::withMessages([\n            $this->username() => [trans(\'auth.failed\')],\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param User $user\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function sendLoginResponse(Request $request, User $user)\n    {\n        $this->clearLoginAttempts($request);\n\n        return \\Response::make([\n            \'user\' => $user,\n            \'token\' => $user->api_token\n        ]);\n    }\n\n    public function username()\n    {\n        return \'email\';\n    }\n}\n```\n\n## 添加登录路由\n\n将 `routes\\api.php` 修改如下：\n```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n\n```\n\n## 调试\n\n测试之前先往 users 表中添加几个用户，以下是我的测试数据。\n\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512221943.png)\n可以看到登录成功并且返回了 token 。\n接下去我们使用获取到的 token 请求需要登录的接口，默认有一个，就是`/user`.\n![](http://caojf.com/wp-content/uploads/2018/05/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180512222458.png)\nok~ 已经成功返回了数据，说明登录成功了！\n\n> 例子中，api_token 是通过 OAuth 2.0 Access Token 的形式传进去的，但这不是唯一的方法，可以查看 TokenGuard 中的 getTokenForRequest 这个方法，它告诉我们可以用四种不同的形式传入 api_token\n\n## 总结\n\n默认的 api token 认证虽然在文档中没有提及如何使用，但是通过查看代码，也很容易使用。但是，在我们不重写或者扩展 `tokenGUard`的情况下，api_token 简直就是裸奔，显然不可能就这样应用到项目中去。个人猜测，框架中提供这个功能是为了让我们更好的理解 api 认证的工作原理，方便我们开发自己需要的 guard ，而且官方文档也推荐我们使用 passport 或者 jwt 进行 api 认证。\n\n本文出于个人对默认配置的好奇进而探究之后写下的一片文章，也借鉴了网上的部分文章（忘记查看的文章地址了，也懒得找了），如有理解不到位或者错误的，请！斧！正！\n\n**欢迎任何形式转载，记得注明出处哦！**', '放假啊来得及伐啦结束的法拉克时代峻峰看啦结束的弗拉加上劳动法课教案楼上的房间阿卡丽撒旦法', 4, 99, 9999, 0, '2020-11-08 16:54:17', '2020-11-08 16:54:17', '2020-12-14 16:49:02', NULL);
COMMIT;

-- ----------------------------
-- Table structure for categories
-- ----------------------------
DROP TABLE IF EXISTS `categories`;
CREATE TABLE `categories` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '分类名称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '分类描述',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '软删除时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='文章分类表\n';

-- ----------------------------
-- Records of categories
-- ----------------------------
BEGIN;
INSERT INTO `categories` VALUES (3, '后端', 'd阿拉丁可使肌肤可拉伸的', '2020-11-08 16:51:17', '2020-11-08 16:51:17', NULL);
INSERT INTO `categories` VALUES (4, '前端', '发所发生的', '2020-11-08 16:51:22', '2020-11-08 16:51:22', NULL);
COMMIT;

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `article_id` int unsigned NOT NULL DEFAULT '0' COMMENT '文章id',
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论者昵称',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论者邮箱',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论内容',
  `state` tinyint NOT NULL COMMENT '状态 0-待审核；1-审核通过；2-驳回',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '软删除时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='文章评论表\n';

-- ----------------------------
-- Records of comments
-- ----------------------------
BEGIN;
INSERT INTO `comments` VALUES (1, 0, 'jeffrey', 'jeffery@local.com', '你好啊', 0, '2020-11-13 13:18:25', '2020-12-17 14:54:54', '2020-12-17 22:54:54');
INSERT INTO `comments` VALUES (2, 1, 'jeffrey', 'jeffery@local.com', '你好啊', 1, '2020-11-13 13:21:28', '2020-11-13 05:23:48', NULL);
INSERT INTO `comments` VALUES (3, 2, 'jack', 'jack@test.com', '# 测试测试\n\n发生可来得及发卡萨丁就房卡死了大', 1, '2020-12-08 22:43:52', '2020-12-08 14:44:23', NULL);
INSERT INTO `comments` VALUES (4, 2, 'jack', 'afsdjfk@jack.com', '发酵饲料党费交阿里斯顿放假阿斯快递费就埃里克森', 1, '2020-12-08 22:55:37', '2020-12-08 14:55:45', NULL);
INSERT INTO `comments` VALUES (5, 2, 'flajsdlkf', 'fasdf', 'fasdlfjalsjfdlas', 1, '2019-12-08 22:58:43', '2020-12-08 15:40:35', NULL);
INSERT INTO `comments` VALUES (6, 2, 'fasfsdf', 'fasdfasdf', '```php\nRoute::namespace(\'Api\')->group(function () {\n    Route::post(\'login\', \'LoginController@login\');\n}); # 登录路由\n\nRoute::middleware(\'auth:api\')->get(\'/user\', function (Request $request) {\n    return $request->user();\n});\n```\n放假阿里山的减肥啦卡放假阿斯利康地方卡萨丁\n', 1, '2020-12-05 23:05:06', '2020-12-08 15:40:22', NULL);
INSERT INTO `comments` VALUES (7, 100, 'lasjdfad', 'fsdfaf', 'fjaskdfsd', 0, '2020-12-11 17:35:02', '2020-12-17 15:16:45', '2020-12-17 23:16:45');
COMMIT;

-- ----------------------------
-- Table structure for files
-- ----------------------------
DROP TABLE IF EXISTS `files`;
CREATE TABLE `files` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文件名称',
  `date` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '日期',
  `full_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文件完整路径名称',
  `md5` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文件md5 值',
  `mime_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文件类型',
  `ext` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文件后缀',
  `size` int NOT NULL DEFAULT '0' COMMENT '文件尺寸',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '删除时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uniq_md5` (`md5`) USING BTREE COMMENT 'md5唯一索引'
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='文件上传记录表';

-- ----------------------------
-- Records of files
-- ----------------------------
BEGIN;
INSERT INTO `files` VALUES (1, '0a8874be3660aeb4315fe7ddd941bd75.png', '2020-11-8', './upload/images/2020-11-8/0a8874be3660aeb4315fe7ddd941bd75.png', '0a8874be3660aeb4315fe7ddd941bd75', 'image/png', '.png', 53730, '2020-11-08 16:52:38', '2020-11-08 16:52:38', NULL);
COMMIT;

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '标签名称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '标签描述',
  `article_count` int unsigned NOT NULL DEFAULT '0' COMMENT '标签下的文章数量',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '软删除时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='文章标签表';

-- ----------------------------
-- Records of tags
-- ----------------------------
BEGIN;
INSERT INTO `tags` VALUES (13, 'php', '世界上最好的语言', 50, '2020-11-08 16:50:34', '2020-12-10 07:28:07', NULL);
INSERT INTO `tags` VALUES (14, 'java', '世界上最流行的语言', 10, '2020-11-08 16:50:44', '2020-12-10 07:28:09', NULL);
INSERT INTO `tags` VALUES (15, 'javaScript', 'web界扛把子', 9, '2020-11-08 16:51:02', '2020-12-10 07:28:12', NULL);
COMMIT;

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '用户昵称',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '用户邮箱',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '登录密码',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted_at` datetime DEFAULT NULL COMMENT '软删除时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='用户表\n';

-- ----------------------------
-- Records of users
-- ----------------------------
BEGIN;
INSERT INTO `users` VALUES (2, 'admin', 'admin@local.com', '1E3c+INIqKtnyTznK3Q1QMuv38sCTdbQakx3HS1wr64=', '2020-11-08 08:49:13', '2020-11-08 08:49:13', NULL);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
